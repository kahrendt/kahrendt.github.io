<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2023-08-10T18:31:33-04:00</updated><id>/feed.xml</id><title type="html">Kevin Ahrendt</title><subtitle>A personal website for 3D printing, mathematics, data science, and home automation.</subtitle><author><name>Kevin Ahrendt</name></author><entry><title type="html">Smart Garage Door Opener with Environmental Sensors</title><link href="/garage-sensors" rel="alternate" type="text/html" title="Smart Garage Door Opener with Environmental Sensors" /><published>2023-08-10T00:00:00-04:00</published><updated>2023-08-10T00:00:00-04:00</updated><id>/garage-sensors</id><content type="html" xml:base="/garage-sensors"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>This project’s goal is to connect my garage door opener to Home Assistant while also collecting environmental data. My garage door opener uses the Chamberlain Security+ 2.0 protocol, so, unfortunately, a simple relay for the door button wires does not work. Fortunately, Paul Wieland has developed and sells  <a href="https://paulwieland.github.io/ratgdo/">ratgdo</a> shields that allow you to use an ESP8266 or ESP32 to control the garage door opener. Finally, I use the  <a href="https://github.com/ESPHome-RATGDO/esphome-ratgdo">esphome-ratgdo custom component</a> to use <a href="https://esphome.io/">ESPHome</a> to control the Garage Door Opener functions while also collecting data from various sensors.</p>

<p>The main focus of this post is to show how I used off-the-shelf components to collect environmental data in my garage rather than the ratgdo project, though I highly recommend the ratgdo shields! The air temperature, humidity, and pressure are all measured. The distance from the ceiling to below is collected. This distance determines whether or not the car is in the garage. The motion sensor automatically turns on the door opener lights when someone enters the garage. All the sensor modules use I2C communication and have Adafruit’s Stemma/SparkFun’s Qwiic connectors for easy development. To use only I2C sensors, I contributed implementations to the ESPHome project for the BMP581, Qwiic PIR (not accepted into the project yet), and Zio Ultrasonic sensors. Instead, I could have used the existing components for the <a href="https://esphome.io/components/binary_sensor/gpio">PIR sensor</a> and the <a href="https://esphome.io/components/sensor/ultrasonic">ultrasonic distance sensor</a>. However, this would require two more GPIOs on the ESP32. Using I2C sensors allow me to keep my wiring minimal, especially since the ESP32 and ratgdo shield are next to the garage door opener, and I wanted to mount the sensors in a more optimal position.</p>

<script src="/assets/js/jquery-1.10.2.min.js"></script>

<script src="/assets/js/lightbox-2.6.min.js"></script>

<link href="/assets/css/lightbox.css" rel="stylesheet" />

<ol>

<a href="/assets/img/garage-opener-sensors/garage-ceiling.jpg" data-lightbox="garage-ceiling" title="Sensors mounted on garage ceiling with an RJ11 cable leading to the garage door opener and the ESP32 on a ratgdo shield.">
<img src="/assets/img/garage-opener-sensors/garage-ceiling.jpg" width="250" />
</a>
<p style="text-align: center;">Sensors mounted on garage ceiling with an RJ11 cable leading to the garage door opener and the ESP32 on a ratgdo shield.</p>

</ol>

<h2 id="components">Components</h2>

<ul>
  <li>Controller
    <ul>
      <li><a href="https://www.amazon.com/gp/product/B08L5XFWN6">D1 ESP32 Mini</a></li>
      <li><a href="https://paulwieland.github.io/ratgdo/">ratgdo shield</a></li>
    </ul>
  </li>
  <li>I2C Components/Sensors
    <ul>
      <li><a href="https://www.adafruit.com/product/4756">Adafruit LTC4311 I2C Extender</a> - Allows for a long I2C cable so that sensors in a more suitable location.</li>
      <li><a href="https://www.adafruit.com/product/5665">Adafruit SHT45 Precision Temperature and Humidity Sensor</a> - Typically measures temperature with ±0.1°C accuracy and humidity with ±1.0% accuracy.</li>
      <li><a href="https://www.sparkfun.com/products/20170">SparkFun BMP581 Pressure Sensor</a> - A pressure sensor with high accuracy, ± 0.5hPa max.</li>
      <li><a href="https://www.sparkfun.com/products/17777">SparkFun Qwiic Ultrasonic Distance Sensor</a> - Used to determine whether the car is parked in the garage. This sensor uses I2C communications for simplified wiring.</li>
      <li><a href="https://www.sparkfun.com/products/17374">SparkFun Qwiic PIR Motion Sensor</a> - A motion sensor that communicates over I2C for simplified wiring.</li>
    </ul>
  </li>
  <li>Wiring
    <ul>
      <li><a href="https://www.amazon.com/dp/B0B9BHX7T3">Right Angle RJ11 Breakout</a> - Used on the sensor end of the phone cord connecting the sensors to the ESP32 board.</li>
      <li><a href="https://www.amazon.com/gp/product/B09HTRKRSH">RJ11 Breakout</a> - Used on the ESP32 end of the cord.</li>
      <li><a href="https://www.amazon.com/gp/product/B00028EXEE">RJ 11 Cord</a></li>
      <li><a href="https://www.sparkfun.com/products/15081">SparkFun Qwiic Cable Kit</a> - Used to connect sensors to one another.</li>
    </ul>
  </li>
  <li>Hardware
    <ul>
      <li><a href="https://www.adafruit.com/product/5780">Adafruit Swirly Aluminum Mounting Grid</a> - Easy way to mount components with varying dimensions.</li>
      <li><a href="https://www.amazon.com/dp/B09F9GMP4W">Nylon Standoff Screw Set</a> - Used to mount the components while not being electrically conductive.</li>
    </ul>
  </li>
</ul>

<h2 id="sensors">Sensors</h2>

<p>The sensors are attached to the Swirly Mounting Grid using hex standoffs. The right-angle RJ11 breakout is similarly attached, with right-angle pins soldered into place. I used a female jump to Qwiic cable to connect to the first sensor. I then used regular Qwiic cables to connect each sensor to the next in a daisy chain. The cables pass through the mounting grid holes with care.</p>

<p>I used a heavy-duty wire cutter to cut off the excess mounting grid. I then placed the cut-off portion on the bottom of the other grid and used M3 screws to connect the two. This extension allowed me to use a 3M Medium Command Strip to attach the sensors to the garage ceiling. Without the extension, the screws from the standoffs extended too far for the Command strip to connect with the one on the ceiling.</p>

<script src="/assets/js/jquery-1.10.2.min.js"></script>

<script src="/assets/js/lightbox-2.6.min.js"></script>

<link href="/assets/css/lightbox.css" rel="stylesheet" />

<ol>

<a href="/assets/img/garage-opener-sensors/sensor-side-gallery/1-swirly-above-precut.jpg" data-lightbox="sensor-side" title="Sensors mounted on Adafruit Swirly before cutting.">
<img src="/assets/img/garage-opener-sensors/sensor-side-gallery/1-swirly-above-precut.jpg" width="250" />
</a>
<p style="text-align: center;">Sensors mounted on Adafruit Swirly before cutting.</p>

<a href="/assets/img/garage-opener-sensors/sensor-side-gallery/2-swirly-below-precut.jpg" data-lightbox="sensor-side" title="Underneath view of sensors mounted on Adafruit Swirly before cutting.">
<img src="/assets/img/garage-opener-sensors/sensor-side-gallery/2-swirly-below-precut.jpg" width="250" />
</a>
<p style="text-align: center;">Underneath view of sensors mounted on Adafruit Swirly before cutting.</p>

<a href="/assets/img/garage-opener-sensors/sensor-side-gallery/3-swirly-above-postcut.jpg" data-lightbox="sensor-side" title="Sensors on Adafruit Swirly after cutting excess.">
<img src="/assets/img/garage-opener-sensors/sensor-side-gallery/3-swirly-above-postcut.jpg" width="250" />
</a>
<p style="text-align: center;">Sensors on Adafruit Swirly after cutting excess.</p>

<a href="/assets/img/garage-opener-sensors/sensor-side-gallery/4-swirly-cut-mounted.jpg" data-lightbox="sensor-side" title="Excess Swirly material mounted to sensor board with M3 screws.">
<img src="/assets/img/garage-opener-sensors/sensor-side-gallery/4-swirly-cut-mounted.jpg" width="250" />
</a>
<p style="text-align: center;">Excess Swirly material mounted to sensor board with M3 screws.</p>

<a href="/assets/img/garage-opener-sensors/sensor-side-gallery/5-command-strip.jpg" data-lightbox="sensor-side" title="Medium command strip applied to bottom of sensors mounted on Adafruit Swirly.">
<img src="/assets/img/garage-opener-sensors/sensor-side-gallery/5-command-strip.jpg" width="250" />
</a>
<p style="text-align: center;">Medium command strip applied to bottom of sensors mounted on Adafruit Swirly.</p>

</ol>

<h2 id="esp32-on-ratgdo">ESP32 on ratgdo</h2>

<p>I soldered an RJ11 breakout directly to the LTC4311 I2C extender board. I used a Qwiic Cable to male jumper adapter to connect it to the ESP32. I soldered some headers on the ESP32 specifically for the I2C connection, as the ratgdo shield seems to have additional circuitry for the broken-out pins. The ratgdo shield is attached to the Garage door opener following the original instructions.</p>

<script src="/assets/js/jquery-1.10.2.min.js"></script>

<script src="/assets/js/lightbox-2.6.min.js"></script>

<link href="/assets/css/lightbox.css" rel="stylesheet" />

<ol>

<a href="/assets/img/garage-opener-sensors/opener-side-gallery/1-rj11-ltc4311.jpg" data-lightbox="opener-side" title="RJ11 breakout board soldered directly to LTC4311 module.">
<img src="/assets/img/garage-opener-sensors/opener-side-gallery/1-rj11-ltc4311.jpg" width="250" />
</a>
<p style="text-align: center;">RJ11 breakout board soldered directly to LTC4311 module.</p>

<a href="/assets/img/garage-opener-sensors/opener-side-gallery/2-rj11-ltc4311-alt.jpg" data-lightbox="opener-side" title="Another view of RJ11 breakout board soldered directly to LTC4311 module.">
<img src="/assets/img/garage-opener-sensors/opener-side-gallery/2-rj11-ltc4311-alt.jpg" width="250" />
</a>
<p style="text-align: center;">Another view of RJ11 breakout board soldered directly to LTC4311 module.</p>

<a href="/assets/img/garage-opener-sensors/opener-side-gallery/3-esp32.jpg" data-lightbox="opener-side" title="ESP32 D1 mini on ratgdo shield, with wiring for I2C sensors.">
<img src="/assets/img/garage-opener-sensors/opener-side-gallery/3-esp32.jpg" width="250" />
</a>
<p style="text-align: center;">ESP32 D1 mini on ratgdo shield, with wiring for I2C sensors.</p>

<a href="/assets/img/garage-opener-sensors/opener-side-gallery/4-esp32-ltc4311.jpg" data-lightbox="opener-side" title="LTC4311 I2C extender connected to ESP32 D1 mini on ratgdo shield.">
<img src="/assets/img/garage-opener-sensors/opener-side-gallery/4-esp32-ltc4311.jpg" width="250" />
</a>
<p style="text-align: center;">LTC4311 I2C extender connected to ESP32 D1 mini on ratgdo shield.</p>

<a href="/assets/img/garage-opener-sensors/opener-side-gallery/5-opener-connections.jpg" data-lightbox="opener-side" title="Wires on garage door opener for ratgdo control.">
<img src="/assets/img/garage-opener-sensors/opener-side-gallery/5-opener-connections.jpg" width="250" />
</a>
<p style="text-align: center;">Wires on garage door opener for ratgdo control.</p>

</ol>

<h2 id="esphome-configuration-highlights">ESPHome Configuration Highlights</h2>

<p>I used the basic configuration from the ESPHome-Ratgdo project as a basis. I do not have any reed switches connected to the ratgdo shield, so I removed them from the configuration. Here are some of the highlights of my ESPHome configuration file.</p>

<h3 id="ultrasonic-sensor-to-detect-if-car-is-present">Ultrasonic Sensor to Detect If Car is Present</h3>

<p>The ultrasonic sensor measures the distance from the ceiling to whatever is below it. When the car is in the garage, the distance is much less than if not. The sensor measures distance in mm, but this measurement is noisy. This noise does not affect the car presence detection, so I convert mm to m using the multiply filter and keep only one decimal of accuracy. The sensor only updates the distance to HA every minute or if the distance changes by 0.1 m using the <code class="language-plaintext highlighter-rouge">or</code>, <code class="language-plaintext highlighter-rouge">delta</code>, and <code class="language-plaintext highlighter-rouge">throttle</code> filters.</p>

<p>A template binary sensor determines the car’s presence state. If the distance is more than 2m, then nothing is below the ceiling; i.e., the car is not in the garage. I use the <code class="language-plaintext highlighter-rouge">invert</code> filter to get the correct logic and the <code class="language-plaintext highlighter-rouge">delayed_on_off</code> filter to debounce any noise.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
sensor:
  - platform: zio_ultrasonic	# included in ESPHome 2023.7
    name: "Distance"
	id: ultrasonic_distance
    update_interval: 1s
    unit_of_measurement: "m"
    accuracy_decimals: 1
    filters:
      - multiply: 0.001     # convert mm to m
      - or:
          - delta: 0.1      # publish if distance changes more than 0.1 meters
          - throttle: 60s	# publish every 60s

binary_sensor:
  # Car Presence from Distance Sensor
  - platform: analog_threshold
    name: "Car"
    sensor_id: ultrasonic_distance
    device_class: presence
    icon: mdi:car
    threshold: 2    # if the distance is more than 2m, then no car is present
    filters:
      - invert
      - delayed_on_off: 5s

</code></pre></div></div>

<h3 id="motion-sensor-to-turn-onoff-lights">Motion Sensor to Turn On/Off Lights</h3>

<p>The Qwiic PIR Motion sensor is an internal component in ESPHome. If it detects motion, it turns on the garage door opener light using the ratgdo component. A <code class="language-plaintext highlighter-rouge">copy</code> sensor turns off the light after not observing any motion for 2.5 minutes. Finally, another <code class="language-plaintext highlighter-rouge">copy</code> sensor sends the motion sensor state to Home Assistant, with the <code class="language-plaintext highlighter-rouge">delayed_on_off</code> filter debouncing the signal.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
external_components:
  - source: github://pr#5194
    components: [ qwiic_pir ]  

binary_sensor:
  # Qwiic PIR Motion Sensor
  - platform: qwiic_pir
    id: qwiic_pir_motion
    on_press:
      then:
        - light.turn_on: ${id_prefix}_light  	

  # Motion sensor filtered for internally turning light off
  - platform: copy
    source_id: qwiic_pir_motion
    id: motion_light_off_delay_filter
    filters:
      - delayed_off: 2.5min
    on_release:
      then:
        - light.turn_off: ratgdo_light 		

  # Motion sensor filtered for HA
  - platform: copy
    source_id: qwiic_pir_motion
    name: "Motion"  
    filters:
      - delayed_on_off:   # debounce the motion state
          time_on: 50ms
          time_off: 15s  

</code></pre></div></div>

<h3 id="environmental-sensors">Environmental Sensors</h3>

<p>The SHT45 is a very accurate temperature and humidity sensor. The BMP581 is a very accurate pressure sensor. The raw measurements are internal sensors. These measurements determine the absolute humidity and dew point in the garage. <code class="language-plaintext highlighter-rouge">Copy</code> sensors send the average value to Home Assistant every 15 seconds using the <code class="language-plaintext highlighter-rouge">throttle_average</code> filter.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
external_components:
  - source: github://pr#4657	# included in ESPHome 2023.8 beta
    components: [ bmp581 ]    

sensor:
  # SHT45 Temperature and Humidity Sensor
  - platform: sht4x
    update_interval: 0.25s
    temperature:
      id: sht45_temperature
    humidity:
      id: sht45_humidity

  # BMP581 Pressure and Temperature Sensor
  - platform: bmp581
    update_interval: 0.25s
    address: 0x47
    temperature:
      id: bmp581_temperature
      oversampling: 8x
    pressure:
      id: bmp581_pressure
      oversampling: 128x

  # Absolute Humidity Sensor derived from temperature and humidity
  - platform: absolute_humidity
    temperature: sht45_temperature
    humidity: sht45_humidity
    id: absolute_humidity_sensor

  # Dew point Sensor computed using Magnus-Tetens formula (uncertain up to 0.35 degrees C)
  - platform: template
    id: dew_point
    update_interval: 1s
    device_class: temperature
    unit_of_measurement: "°C"
    accuracy_decimals: 1                                # formula is uncertain up to 0.35 degrees C = 0.63 degrees F for usual indoor temperatures
    lambda: |- 
        const float alpha = 6.112;                      // (hPa)
        const float beta = 17.62;
        const float lambda = 243.12;                    // (degrees C)

        float RH = id(sht45_humidity).state;               // Relative Humidity
        float T = id(sht45_temperature).state;                    // Temperature in (degrees C)

        float H = log( RH/100 ) + beta*T/(lambda+T);
        return (lambda)*H/(beta - H);  

  # SHT45 Sensor
  - platform: copy
    source_id: sht45_temperature
    name: "Temperature"
    accuracy_decimals: 1
    filters:
      - throttle_average: 15s
  - platform: copy
    source_id: sht45_humidity
    name: "Humidity"
    accuracy_decimals: 1
    filters:
      - throttle_average: 15s

    # BMP581 Pressure Sensor
  - platform: copy
    source_id: bmp581_pressure
    name: "Pressure"
    filters:
      - throttle_average: 15s
  - platform: copy
    source_id: bmp581_temperature
    name: "BMP581 Temperature"
    entity_category: diagnostic    
    filters:
      - throttle_average: 15s

  # Humidity Derived Sensors
  - platform: copy
    source_id: absolute_humidity_sensor
    name: "Absolute Humidity"
    filters:
      - throttle_average: 15s     
  - platform: copy
    source_id: dew_point
    name: "Dew Point"
    filters:
      - throttle_average: 15s   

</code></pre></div></div>]]></content><author><name>Kevin Ahrendt</name></author><category term="programming" /><category term="smart-home" /><category term="esphome" /><category term="data" /><summary type="html"><![CDATA[Introduction]]></summary></entry><entry><title type="html">Long-Term Data Storage of ESPHome Sensor Data</title><link href="/long-term-storage-of-esphome-sensor-data" rel="alternate" type="text/html" title="Long-Term Data Storage of ESPHome Sensor Data" /><published>2023-06-15T00:00:00-04:00</published><updated>2023-06-15T00:00:00-04:00</updated><id>/long-term-storage-of-esphome-sensor-data</id><content type="html" xml:base="/long-term-storage-of-esphome-sensor-data"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>I currently have 26 devices running ESPHome that collect data from our home. The various devices include environmental sensors like air pressure, temperature, humidity, and levels for CO2, VOC levels, and particulate matter. Other devices collect power/energy usage using smart plugs or a whole house power monitoring device (<a href="https://www.emporiaenergy.com/how-the-vue-energy-monitor-works">Emporia Vue 2</a> with <a href="https://github.com/emporia-vue-local/esphome">custom component</a>). Altogether, these devices generate a significant amount of raw data. That data is partially filtered and sent to my Home Assistant server. Home Assistant then stores the filtered data for about ten days. After that time, Home Assistant only keeps aggregates like the mean, minimum, and maximum for <a href="https://data.home-assistant.io/docs/statistics/">1-hour intervals</a>. I plan to collect all this measurement data in a separate database for permanent storage. I will retain raw data for one month and permanently retain all data aggregated over one-minute intervals.</p>

<h2 id="possible-approaches">Possible Approaches</h2>

<p>There are several established ways to accomplish this goal.</p>
<ol>
  <li>Run <a href="https://www.influxdata.com/">InfluxDB</a> (or <a href="https://victoriametrics.com/">VictoriaMetrics</a>) and use Home Assistant’s <a href="https://www.home-assistant.io/integrations/influxdb/">component</a> to use it for long-term storage. There are many tutorials available for this setup, for example <a href="https://dev.to/admantium/home-assistant-collecting-sensor-data-with-influxdb-3mfl">here</a> or <a href="https://thesmarthomejourney.com/2021/05/02/grafana-influxdb-home-assistant/">here</a>.
    <ul>
      <li>Advantages:
        <ul>
          <li>Relatively easy to setup and use
            <ul>
              <li>InfluxDB can automatically downsample the data after a set time.</li>
              <li>Widespread community use, so many resources available for help</li>
            </ul>
          </li>
          <li>Disadvantages:
            <ul>
              <li>Requires Home Assistant to be running (generally not a problem, as restarts are rarely needed)</li>
              <li>Requires all data to be passed through Home Assistant, so for more complete data, all sensors should have a short update interval. I generally do not need my Home Assistant instance to have such small update intervals for automations, so unnecessary data is being sent only to be passed on to InfluxDB.
                <ul>
                  <li>Even with a short update window, the sent data could easily miss a maximum value if measured between updates.</li>
                </ul>
              </li>
              <li>Not all data sources (not necessarily smart-home data) can easily be integrated into Home Assistant to be passed onto long-term storage.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Use a data scraping program like <a href="https://www.influxdata.com/time-series-platform/telegraf/">Telegraf</a> to collect data directly from the device and send it to a database.
    <ul>
      <li>Advantages:
        <ul>
          <li>Removes Home Assistant from the long-term data collection process.</li>
          <li>Telegraf can aggregate incoming data and provide typical summary statistics like minimum, maximum, and mean.</li>
          <li>Disadvantages:
            <ul>
              <li>Data is collected at a set interval (the default is five seconds). Any summary statistics are limited to one reading every five seconds, so it could easily miss a maximum value if measured between updates.</li>
              <li>Collecting data directly from ESPHome is challenging. There are several options.
                <ul>
                  <li>Use the <a href="https://esphome.io/components/prometheus.html">Prometheus</a> ESPHome component to allow Telegraf to scrape sensor measurements
                    <ul>
                      <li>Requires using the Arduino core instead of the (generally) better-performing ESP-IDF framework</li>
                      <li>Adds significant overhead on the ESP device</li>
                    </ul>
                  </li>
                  <li>Setup an MQTT server like <a href="https://mosquitto.org/">Mosquitto</a> and configure ESPHome to send data to it using the <a href="https://esphome.io/components/mqtt.html">MQTT component</a>
                    <ul>
                      <li>Increases complexity.</li>
                      <li>Cannot specify which sensors use the native Home Assistant API and which use MQTT.</li>
                      <li>Overhead on the ESP device is minimal.</li>
                    </ul>
                  </li>
                  <li>Use the <a href="https://esphome.io/components/http_request.html">HTTP Request Component</a> to send data directly to the database.
                    <ul>
                      <li>Tedious configuration for a large number of sensors</li>
                      <li>Adds significant overhead on the ESP device</li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<h2 id="current-plan">Current Plan</h2>

<p>I will use a variation of the second option and overcome the listed disadvantages with some custom code. The long-term data will be stored using a VictoriaMetrics cluster[https://docs.victoriametrics.com/Cluster-VictoriaMetrics.html]. The VictoriaMetrics cluster will have two separate storage instances running; one for high-frequency data retained for one month, and the other will store aggregated data at a lower frequency for permanent retention. Data will be collected using Telegraf’s <a href="https://www.influxdata.com/integration/mqtt-telegraf-consumer/">MQTT consumer plugin</a> from a Mosquitto MQTT Broker. The ESPHome devices will aggregate and send data over MQTT for long-term storage.</p>

<p>![[Data Retention Flow Chart.png]]</p>

<p><img src="assets/img/data-retention-flow-chart.png" alt="Data Retention Flow Chart" />
<em>Flow chart showing where data is sent from an ESPHome Device</em></p>

<p>We can break this down into three steps:</p>
<ol>
  <li>Configure VictoriaMetrics and Telegraf for data collection and storage.</li>
  <li>Modify ESPHome’s MQTT code to restrict which sensors send measurements via API or MQTT
    <ul>
      <li>Sensors with a long update interval are exposed to only Home Assistant.</li>
      <li>Sensor measurement aggregates are sent only via MQTT.</li>
    </ul>
  </li>
  <li>Develop a statistic component for ESPHome that aggregates the data over a sliding window quickly and efficiently.
    <ul>
      <li>ESPHome has <a href="https://esphome.io/components/sensor/index.html#sensor-filters">sensor filters</a> built-in for the minimum, maximum, and mean (among other statistics) over a sliding window. These work well for one or two sensors, but if we want aggregated data for many sensors, this quickly has issues.
        <ul>
          <li>Each aggregate requires a <a href="https://esphome.io/components/copy.html">Copy component</a> with the appropriate filter applied. It is tedious to configure several different aggregates for many different source sensors.</li>
          <li>The algorithms for finding the aggregates are inefficient in memory and computational time. Using the built-in filters to compute statistics like minimum, maximum, and mean for several sensors over large sliding windows can crash the device.</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<h2 id="future">Future</h2>

<p>I will write future posts describing my implementation of each of these steps. I will heavily focus on describing the custom statistics component I have developed that is computational and memory efficient.</p>]]></content><author><name>Kevin Ahrendt</name></author><category term="programming" /><category term="smart-home" /><category term="esphome" /><category term="statistics" /><category term="data" /><summary type="html"><![CDATA[Introduction]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/chart-bell-curve.png" /><media:content medium="image" url="/chart-bell-curve.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Quantifying New Exhaust Fan Performance with Data from ESPHome</title><link href="/quantifying-new-exhaust-fan" rel="alternate" type="text/html" title="Quantifying New Exhaust Fan Performance with Data from ESPHome" /><published>2023-03-26T00:00:00-04:00</published><updated>2023-03-26T00:00:00-04:00</updated><id>/quantifying-new-exhaust-fan</id><content type="html" xml:base="/quantifying-new-exhaust-fan"><![CDATA[<h2 id="introduction">Introduction</h2>

<p>Our home’s original master bathroom exhaust fan could not remove all excess moisture when showering. The mirror would fog over almost completely, and water would condense on the walls near the ceiling. We replaced the fan, and I wanted to quantify and test whether the new fan was an improvement. I gathered summary statistics from an air velocity sensor placed under the closed bathroom door using ESPHome. I then used a t-test to determine whether the changes indicated an improvement. The new fan and ducting show a statistically significant improvement, and (most importantly) moisture does not accumulate.</p>

<p>The bathroom is 83 square feet, and the previous exhaust fan was rated to exhaust 50 Cubic Feet of air per Minute (CFM). While this meets the <a href="https://codes.iccsafe.org/content/NYSRC2020P1/chapter-15-exhaust-systems#NYSRC2020P1_Pt05_Ch15_SecM1505.4.4">local Residential Code</a>, a common <a href="https://www.hvi.org/resources/publications/bathroom-exhaust-fans/">rule of thumb</a> recommends 1 CFM per square foot. We replaced the old bathroom fan with a <a href="https://na.panasonic.com/us/home-and-building-solutions/ventilation-indoor-air-quality/ventilation-fans/whisperfitr-dc-fan-50-80-110-cfm">Panasonic FV-0511VF1</a>. While this was an improvement compared to the original fan, it still did not eliminate the moisture issues. We improved the fan’s performance by straightening out the duct in the attic instead of immediately making a sharp turn in the attic. We then replaced the previous 3-inch ducting with an insulated 4-inch duct while also properly terminating the duct with an <a href="https://na.panasonic.com/us/home-and-building-solutions/ventilation-indoor-air-quality/ventilation-accessories/ezsoffit-venttm-soffit-termination-system">appropriate vent</a>. For comparison, the old duct end simply rested on the vinyl soffit. Finally, we increased the exhaust rate setting on the new fan from 50 CFM to 110 CFM, eliminating the moisture build-up.</p>

<h2 id="experiment-setup">Experiment Setup</h2>

<p>I used an <a href="https://www.sparkfun.com/products/18377">FS3000 air velocity sensor</a> to quantify the exhaust rate with each change to the setup. I placed the air velocity sensor under the closed bathroom door and turned on the fan. I wrote a custom component to interface the sensor with ESPHome to easily collect the data. (My pull request has since been accepted, and ESPHome now supports the <a href="https://esphome.io/components/sensor/fs3000.html">sensor natively</a>.) The sensor measured the air velocity once per second. Additionally, I calculated the standard deviation over 60 measurements (1 minute) of the air velocities using the filter code detailed in this <a href="/standard-deviation-esphome">post</a>. I also collected the minimum, maximum, and average air velocity over the previous 60 measurements using built-in <a href="https://esphome.io/components/sensor/index.html#sensor-filters">ESPHome sensor filters</a>. See the <a href="#ESPHome-Sensor-YAML">ESPHome Sensor YAML section</a> section at the end of this post for the specific configuration details. After waiting several minutes to ensure the fans were up to full speed, I recorded the data.</p>

<p><img src="assets/img/exhaust-fan/velocity_sensor_door_closed_wide.jpg" alt="FS3000 velocity sensor in door-frame" />
<em>FS3000 sensor placed under the door. Also pictured is a <a href="https://www.sparkfun.com/products/16988">Qwiicbus endpoint</a> to use an ethernet cable for I2C communication.</em></p>

<h2 id="conclusions">Conclusions</h2>

<p>We use the measured air velocity underneath the bathroom door as a proxy for the amount of air the bathroom fan exhausts. Replacing the old bathroom fan with the Panasonic fan resulted in a significant improvement without modifying the ducting. Straightening the duct also resulted in a significant increase in the amount of air exhausted.</p>

<p>Replacing the 3-inch duct without termination with a 4-inch duct terminated with a soffit vent reduced the air exhausted by a statistically significant amount. The decrease is minimal in practice, resulting in an average under-door velocity decrease of only 0.04, or a 4.3% reduction. While the larger duct, in theory, should improve the amount of air exhausted, it appears that the soffit vent termination causes the reduction. This fan increases its power to counteract duct resistance to achieve the set CFM level. Since the duct length is short (approximately 3 feet), the fan seems to be able to compensate for the difference between a 3-inch duct and a 4-inch duct. Replacing the duct and terminating it with a vent reduced the fan’s noise significantly, which indicates that the fan did not need to work as hard despite having the soffit vent present. This reduction is acceptable, as no ducting termination is problematic long-term for the house’s structure. Previously, the moist air was not fully exhausted, as a large fraction of moisture remained in the attic. Before terminating the duct, a humidity sensor in the attic showed an increase whenever the exhaust fan ran during a shower. After adding the terminating vent, there is no increase in attic humidity levels when the fan runs during a shower.</p>

<p>Finally, as expected, increasing the fan’s setting to 110 CFM from 50 CFM resulted in a significant improvement. At 110 CFM, this exceeds the rule-of-thumb of having 1 CFM per square foot. When set to the 50 CFM setting with the new fan and ducting, we still experienced mirror fogging and moisture condensing on the walls. After changing the setting, this is no longer a problem.</p>

<h2 id="data">Data</h2>

<table>
  <thead>
    <tr>
      <th> </th>
      <th style="text-align: center"><strong>Average</strong> \(\left(\frac{\text{m}}{\text{s}}\right)\)</th>
      <th style="text-align: center"><strong>Minimum</strong> \(\left(\frac{\text{m}}{\text{s}}\right)\)</th>
      <th style="text-align: center"><strong>Maximum</strong> \(\left(\frac{\text{m}}{\text{s}}\right)\)</th>
      <th style="text-align: center"><strong>Standard Deviation</strong> \(\left(\frac{\text{m}}{\text{s}}\right)\)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Fan Off</strong></td>
      <td style="text-align: center">0.02</td>
      <td style="text-align: center">0.00</td>
      <td style="text-align: center">0.04</td>
      <td style="text-align: center">0.01</td>
    </tr>
    <tr>
      <td><strong>Old Exhaust Fan</strong><br />50 CFM<br />3 inch duct, kinked<br />no soffit termination</td>
      <td style="text-align: center">0.66</td>
      <td style="text-align: center">0.62</td>
      <td style="text-align: center">0.66</td>
      <td style="text-align: center">0.01</td>
    </tr>
    <tr>
      <td><strong>New Exhaust Fan</strong><br />50 CFM<br />3 inch duct, kinked<br />no soffit termination</td>
      <td style="text-align: center">0.77</td>
      <td style="text-align: center">0.74</td>
      <td style="text-align: center">0.81</td>
      <td style="text-align: center">0.03</td>
    </tr>
    <tr>
      <td><strong>New Fan<br />50 CFM</strong><br />3 inch duct, straightened<br />no soffit termination</td>
      <td style="text-align: center">0.92</td>
      <td style="text-align: center">0.86</td>
      <td style="text-align: center">0.99</td>
      <td style="text-align: center">0.03</td>
    </tr>
    <tr>
      <td><strong>New Fan<br />50 CFM</strong><br />4 inch duct<br />terminated with soffit vent</td>
      <td style="text-align: center">0.88</td>
      <td style="text-align: center">0.86</td>
      <td style="text-align: center">0.91</td>
      <td style="text-align: center">0.01</td>
    </tr>
    <tr>
      <td><strong>New Fan<br />110 CFM</strong><br />4 inch duct<br />terminated with soffit vent</td>
      <td style="text-align: center">1.51</td>
      <td style="text-align: center">1.48</td>
      <td style="text-align: center">1.58</td>
      <td style="text-align: center">0.02</td>
    </tr>
  </tbody>
</table>

<h2 id="statistical-testing">Statistical Testing</h2>

<p>Due to this project taking a long time, I collected most of these summary statistics on different days with different ambient weather conditions. There could have been a more pronounced natural draft, but I only gathered the first three rows of data on the same day. I did not account for this potential confounding factor.</p>

<p>We use a one-sided, two-sample <a href="https://en.wikipedia.org/wiki/Student%27s_t-test">t-test</a> comparing the difference between the mean air velocities to test whether there are significant increases or decreases after changing the setup. The sample size is 60, as the summary statistics reflect a 60-observation sliding window. The t-test helps us determine whether there is evidence to support if the upgrades increased the air velocity underneath the door. We assume the measured air velocities follow a normal distribution when using a t-test, which may not be appropriate. A better approach is to record the observed air velocities for all 60 measurements instead of the summary statistics. Then, we would use a <a href="https://en.wikipedia.org/wiki/Kolmogorov%E2%80%93Smirnov_test">Kolmogorov-Smirnov test</a>, which does not assume the samples’ observations follow a specific distribution.</p>

<p>Comparing the Old Exhaust Fan sample with the New Exhaust Fan sample with the same rated 50 CFM and kinked 3-inch duct, we get a p-value of less than 0.0001. There is strong evidence that the new exhaust fan resulted in a higher under-door air velocity.</p>

<p>Comparing the samples for New Exhaust Fan with the 3-inch duct kinked or straightened, we get a p-value of less than 0.0001. This is strong evidence that straightening the duct increased under-door air velocity.</p>

<p>Comparing the samples for the New Exhaust Fan with a straightened 3-inch duct without termination versus a 4-inch duct with soffit termination, we get a p-value of less than 0.0001. There is strong evidence that replacing the 3-inch duct without termination with a 4-inch duct with a vent termination reduced the under-door air velocity.</p>

<p>Comparing the samples for the New Exhaust fan set to 50 CFM versus 110 CFM, the p-value is less than 0.0001. This is strong evidence that the fan setting modification increased the under-door air velocity.</p>

<h2 id="photos">Photos</h2>

<p><img src="assets/img/exhaust-fan/old_exhaust_fan.jpg" alt="Old exhaust fan in attic" />
<em>The old exhaust fan with insulation cleared. The exhaust duct is kinked immediately after leaving the fan. It was present before the insulation was pulled aside and after putting it back.</em></p>

<p><img src="assets/img/exhaust-fan/no_duct_termination.jpg" alt="Exhaust duct from attic" />
<em>The old 3 inch duct without any sharp kinks immediately after leaving the fan. It has no termination in the soffit bay.</em></p>

<h2 id="esphome-sensor-yaml">ESPHome Sensor YAML</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sensor:
  - platform: fs3000
    name: "Velocity"
    id: velocity_mps
    i2c_id: qwik_bus
    model: 1005
    update_interval: 1s
  - platform: copy
    name: "Velocity Average (1 min)"
    source_id: velocity_mps
    filters:
      - sliding_window_moving_average:
          window_size: 60
          send_every: 15
  - platform: copy
    name: "Velocity Maximum (1 min)"
    source_id: velocity_mps
    filters:
      - max:
          window_size: 60
          send_every: 15
  - platform: copy
    name: "Velocity Minimum (1 min)"
    source_id: velocity_mps
    filters:
      - min:
          window_size: 60
          send_every: 15                 
  - platform: copy
    name: "Velocity Standard Deviation (1 min)"
    source_id: velocity_mps
    filters:
      - lambda: |-
          // max measurements to store for computing standard deviation
          const uint8_t window_size_ = 60;
          // compute and send the standard deviation after this many measurements
          const uint8_t send_every_ = 15; 

          static std::deque&lt;float&gt; queue_;
          static uint8_t send_at_ = 0;
          
          // If we have more entries in queue_ than the window_size_, 
          // then pop them off
          while (queue_.size() &gt;= window_size_) {
            queue_.pop_front();
          }

          // add the newest reading to queue_
          queue_.push_back(x);

          if (++send_at_ &gt;= send_every_) {
            send_at_ = 0;

            float Ex = 0.0;
            float Ex2 = 0.0;
            size_t count = 0;

            float K = queue_.front();
            
            for (auto v: queue_) {
              if (!std::isnan(v)) {
                // Welford's algorithm to avoid catostrophic cancellation
                //  - This is achieved by subtracting the oldest reading from 
                //    each measurement. If not done, then the sum of the 
                //    measurements squared and the square of the measurements 
                //    summed may be quite large, and their difference can be 
                //    problematic resulting in catostrophic cancellation

                // counts valid measurements
                count += 1;
                // sums the measurement minus the oldest reading
                Ex += v - K;
                 // sums the measurement minus the oldest reading squared
                Ex2 += pow(v-K,2);
              }
            }

            float standard_deviation = NAN;
            // If we have at least one valid reading, then compute the 
            // variance and standard deviation, otherwise it will remain NAN
            if (count) {
              float variance = (Ex2 - pow(Ex, 2)/count) / (count-1);
              // standard deviation is the square root of the variance
              standard_deviation = sqrt(variance); 
            }

            return standard_deviation;
          }
          return {};
</code></pre></div></div>]]></content><author><name>Kevin Ahrendt</name></author><category term="programming" /><category term="smart-home" /><category term="esphome" /><category term="statistics" /><category term="data" /><summary type="html"><![CDATA[Introduction]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/exhaust-fan/velocity_sensor_door_open.jpg" /><media:content medium="image" url="/exhaust-fan/velocity_sensor_door_open.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Standard Deviation Filter for ESPHome</title><link href="/standard-deviation-esphome" rel="alternate" type="text/html" title="Standard Deviation Filter for ESPHome" /><published>2023-03-24T00:00:00-04:00</published><updated>2023-03-24T00:00:00-04:00</updated><id>/standard-deviation-esphome</id><content type="html" xml:base="/standard-deviation-esphome"><![CDATA[<p>The <a href="https://en.wikipedia.org/wiki/Standard_deviation">standard deviation</a> of a set of sensor readings measures the variation in the sensor’s observations. A standard deviation close to zero implies the sensor observations tend to be near the mean/average of all observations. In other words, the measurements are consistent and not dispersed. A standard deviation much larger than zero implies the opposite. In other words, the observations are dispersed and not consistent. If we compute the standard deviation from the set of measurements from a sensor, we can determine whether or not those observations are consistent.</p>

<p>The following code for ESPHome uses a <a href="https://esphome.io/components/sensor/index.html#lambda">custom lambda filter</a> to compute the standard deviation of measurements from a sensor. It applies the filter to a <a href="https://esphome.io/components/copy.html">copy integration</a> sensor, which requires another defined sensor with a designated id. We could apply the lambda filter directly to a sensor itself, but then ESPHome would send only the standard deviation of the measurements to Home Assistant and not the actual measurement value. The parameters <code class="language-plaintext highlighter-rouge">window_size_</code> and <code class="language-plaintext highlighter-rouge">send_every_</code> correspond to the configuration values <code class="language-plaintext highlighter-rouge">window_size</code> and <code class="language-plaintext highlighter-rouge">send_every</code> for any of the built-in ESPHome sensor filters.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sensor:
  - platform: copy
    name: "Standard Deviation of measurements"
    source_id: another_sensor_id
    filters:
      - lambda: |-
          // max measurements to store for computing standard deviation
          const uint8_t window_size_ = 60;
          // compute and send the standard deviation after this many measurements
          const uint8_t send_every_ = 15; 

          static std::deque&lt;float&gt; queue_;
          static uint8_t send_at_ = 0;
          
          // If we have more entries in queue_ than the window_size_, 
          // then pop them off
          while (queue_.size() &gt;= window_size_) {
            queue_.pop_front();
          }

          // add the newest reading to queue_
          queue_.push_back(x);

          if (++send_at_ &gt;= send_every_) {
            send_at_ = 0;

            float Ex = 0.0;
            float Ex2 = 0.0;
            size_t count = 0;

            float K = queue_.front();
            
            for (auto v: queue_) {
              if (!std::isnan(v)) {
                // Welford's algorithm to avoid catastrophic cancellation
                //  - This is achieved by subtracting the oldest reading from 
                //    each measurement. If not done, then the sum of the 
                //    measurements squared and the square of the measurements 
                //    summed may be quite large, and their difference can be 
                //    problematic resulting in catastrophic cancellation

                // counts valid measurements
                count += 1;
                // sums the measurement minus the oldest reading
                Ex += v - K;
                 // sums the measurement minus the oldest reading squared
                Ex2 += pow(v-K,2);
              }
            }

            float standard_deviation = NAN;
            // If we have at least one valid reading, then compute the 
            // variance and standard deviation, otherwise it will remain NAN
            if (count) {
              float variance = (Ex2 - pow(Ex, 2)/count) / (count-1);
              // standard deviation is the square root of the variance
              standard_deviation = sqrt(variance); 
            }

            return standard_deviation;
          }
          return {};
</code></pre></div></div>

<p>We compute the standard deviation by taking the square root of the variance. If we naïvely compute the variance, then we may encounter <a href="https://en.wikipedia.org/wiki/Catastrophic_cancellation">catastrophic cancellation</a>. Using the naïve approach, we would compute the sum of the measurements and the sum of the squared measurements. Computing the variance involves taking the difference between the sum of the squared measurements and the sum of the measurements that are then squared and divided by the number of measurements. If the measurements are large values to start, and if there are a large number of measurements, then these two numbers can be very similar, which can cause cancellation to a degree where the floating-point arithmetic cannot be precise enough. We can avoid this by using <a href="https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance">Welford’s algorithm</a> to compute the variance in a single pass.</p>]]></content><author><name>Kevin Ahrendt</name></author><category term="programming" /><category term="smart-home" /><category term="esphome" /><category term="programming" /><category term="mathematics" /><category term="statistics" /><summary type="html"><![CDATA[The standard deviation of a set of sensor readings measures the variation in the sensor’s observations. A standard deviation close to zero implies the sensor observations tend to be near the mean/average of all observations. In other words, the measurements are consistent and not dispersed. A standard deviation much larger than zero implies the opposite. In other words, the observations are dispersed and not consistent. If we compute the standard deviation from the set of measurements from a sensor, we can determine whether or not those observations are consistent.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/chart-bell-curve.png" /><media:content medium="image" url="/chart-bell-curve.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Approximating Dew Points in ESPHome</title><link href="/approximating-dew-points" rel="alternate" type="text/html" title="Approximating Dew Points in ESPHome" /><published>2022-07-20T00:00:00-04:00</published><updated>2022-07-20T00:00:00-04:00</updated><id>/approximating-dew-points</id><content type="html" xml:base="/approximating-dew-points"><![CDATA[<p>A dew point is a practical measure of moisture in the air that is a good proxy for occupant comfort. It is better to determine if a space feels “muggy” than relative humidity. The dew point is the air temperature, assuming the amount of water vapor in the air remains constant, in which the relative humidity of the air would be 100%. If the temperature decreases to be less than the dew point, water will condense on surfaces <a class="citation" href="#nws-dewpoint_vs_humidity">[1]</a>. Another way to quantify the absolute quantity of moisture in the air is to use <a href="https://esphome.io/components/sensor/absolute_humidity.html">absolute humidity</a>, but it is arguably easier to interpret a dew point has the same units as a regular temperature measurement.</p>

<p>Unfortunately, cheap, readily available electronic sensors that measure dew point directly are unavailable. However, we can approximate the dew point temperature relatively quickly and accurately by knowing the relative humidity and air temperature, which many sensors make available! As a note, there are many ways to approximate the dew point. However, we will base our approximation on a calculation that uses the Magnus formula described in <a class="citation" href="#sensirion-dew_point_calculation">[2]</a>.</p>

<p>The dew point temperature \( T_{dp} \) (in \( ^\circ \text{C} \)) is approximated by</p>

\[T_{dp} \left( T, RH \right) = \frac{\lambda\left( \ln\left(\frac{RH}{100}\right) + \frac{\beta T}{\lambda+T} \right)}{\beta-\left( \ln\left(\frac{RH}{100}\right) + \frac{\beta T}{\lambda+T} \right)},\]

<p>where \( T \) is the ambient temperature in \( ^\circ \text{C} \), \( RH \) is the relative humidity (as a number between 0 and 100), \( \alpha = 6.112 \text{hPa} \), \( \beta = 17.62 \), and \( \lambda = 243.12 ^\circ \text{C} \). In our equivalent C++ implementation, we use a temporary variable of</p>

\[H(T,RH) = \ln\left(\frac{RH}{100}\right) + \frac{\beta T}{\lambda+T},\]

<p>and return the dew point in \(^\circ \text{C}\) with</p>

\[T_{dp}(H) = \frac{\lambda H}{\beta - H}.\]

<p>Since I use ESPHome to control my sensors, the ESP32 will calculate the dew point directly on the device using a template sensor. The following template sensor assumes there are separate humidity and temperature sensors with an ESPHome id of “humidity” and “temperature” respectively.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sensor:
  - platform: template
    name: "${upper_device_name} Dew Point"
    id: dewPoint
    update_interval: 30s
    device_class: temperature
    unit_of_measurement: "°C"
    accuracy_decimals: 0                                # formula is uncertain up to 0.35 degrees C = 0.63 degrees F for usual indoor temperatures
    lambda: |- 
        const float alpha = 6.112;                      // (hPa)
        const float beta = 17.62;
        const float lambda = 243.12;                    // (degrees C)

        float RH = id(humidity).raw_state;              // Relative Humidity
        float T = id(temperature).raw_state;            // Temperature in (degrees C)

        float H = log( RH/100 ) + beta*T/(lambda+T);
        return (lambda)*H/(beta - H);
</code></pre></div></div>

<h1 id="references">References</h1>
<ol class="bibliography"><li><span id="nws-dewpoint_vs_humidity">1. Service USNW Dew point vs. Humidity. Available at: https://www.weather.gov/arx/why_dewpoint_vs_humidity.</span></li>
<li><span id="sensirion-dew_point_calculation">2. Application Note: Dew-Point Calculation Sensirion AG.</span></li></ol>]]></content><author><name>Kevin Ahrendt</name></author><category term="programming" /><category term="smart-home" /><category term="esphome" /><category term="programming" /><category term="mathematics" /><summary type="html"><![CDATA[A dew point is a practical measure of moisture in the air that is a good proxy for occupant comfort. It is better to determine if a space feels “muggy” than relative humidity. The dew point is the air temperature, assuming the amount of water vapor in the air remains constant, in which the relative humidity of the air would be 100%. If the temperature decreases to be less than the dew point, water will condense on surfaces [2]. Another way to quantify the absolute quantity of moisture in the air is to use absolute humidity, but it is arguably easier to interpret a dew point has the same units as a regular temperature measurement.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/thermometer-water.png" /><media:content medium="image" url="/thermometer-water.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Hyperbolic Paraboloid Printed Surface Classroom Activity</title><link href="/hyperbolic_paraboloid_activity" rel="alternate" type="text/html" title="Hyperbolic Paraboloid Printed Surface Classroom Activity" /><published>2019-08-19T00:00:00-04:00</published><updated>2019-08-19T00:00:00-04:00</updated><id>/hyperbolic_paraboloid_activity</id><content type="html" xml:base="/hyperbolic_paraboloid_activity"><![CDATA[<h2 id="description">Description:</h2>
<p>These are models for several quadric surfaces that are useful for Multivariable Calculus classes. The surfaces include raised bumps representing traces. The models allow students to make the connection between the abstract formula/2D pictures to the actual surface in 3D. I have also inclued an in-classroom activity that I used when teaching Multivariable Calculus. Each group was given a printed version of the hyperbolic paraboloid surface, and then they worked through the questions on the activity together.</p>

<h2 id="design-process">Design process:</h2>
<p>I used Mathematica to generate the surfaces using the included Mathematica code. I used Slic3r to fix errors in the STL and to split the hyperbolic paraboloid into two pieces to make it printable without supports.</p>

<h2 id="post-print-finishing">Post-print finishing:</h2>
<p>Glue the hyperbolic paraboloid pieces together using super glue. If printed in ABS, you can “weld” the two pieces together with acetone.</p>

<h2 id="files">Files</h2>
<ul>
  <li>Hyperbolic Paraboloid Classroom Activity: <a href="assets/3d-models/hyperbolic_paraboloid/Hyperbolic_Paraboloid_Activity.pdf">Hyperbolic_Paraboloid_Activity.pdf</a></li>
  <li>Hyperbolic Paraboloid Surface (split into two pieces): <a href="assets/3d-models/hyperbolic_paraboloid/Hyperbolic_Paraboloid.stl">Hyperbolic_Paraboloid.stl</a></li>
  <li>Hyperboloid in One sheet Surface: <a href="assets/3d-models/hyperbolic_paraboloid/Hyperboloid_One_Sheet.stl">Hyperboloid_One_Sheet.stl</a></li>
  <li>Elliptic Paraboloid Surface: <a href="assets/3d-models/hyperbolic_paraboloid/Elliptic_Paraboloid.stl">Elliptic_Paraboloid.stl</a></li>
  <li>Double Cone Surface: <a href="assets/3d-models/hyperbolic_paraboloid/Double_Cone.stl">Double_Cone.stl</a></li>
  <li>Mathematica Notebook: <a href="assets/3d-models/hyperbolic_paraboloid/Quadrics.nb">Quadrics.nb</a></li>
</ul>]]></content><author><name>Kevin Ahrendt</name></author><category term="3d-printing" /><category term="3d printing" /><category term="mathematics" /><category term="teaching" /><summary type="html"><![CDATA[Description: These are models for several quadric surfaces that are useful for Multivariable Calculus classes. The surfaces include raised bumps representing traces. The models allow students to make the connection between the abstract formula/2D pictures to the actual surface in 3D. I have also inclued an in-classroom activity that I used when teaching Multivariable Calculus. Each group was given a printed version of the hyperbolic paraboloid surface, and then they worked through the questions on the activity together.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/print-hyperbolic-paraboloid.jpg" /><media:content medium="image" url="/print-hyperbolic-paraboloid.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Continuous Fractional Derivative of Quadratic Function</title><link href="/continuous_quadratic_print" rel="alternate" type="text/html" title="Continuous Fractional Derivative of Quadratic Function" /><published>2019-08-05T00:00:00-04:00</published><updated>2019-08-05T00:00:00-04:00</updated><id>/continuous_quadratic_print</id><content type="html" xml:base="/continuous_quadratic_print"><![CDATA[<h2 id="description">Description:</h2>
<p>This is a three dimensional graph of \(x^2\), with one axis representing the Riemann-Liouville fractional derivative order ranging from 0 to 2. The \(x\)-axis ranges from 1 to 7. The zeroth order derivative, given by \(x^2\), the first derivative, given by \(2x\), and the second derivative, given by \(2\) are highlighted with a ridge. The Riemann-Liouville fractional derivative is continuous with the respect to the order of the derivative, so the transition between the zeroth, first, and second derivative to the fractional derivatives in between results in a smooth graph.</p>

<h2 id="design-process">Design process:</h2>
<p>I used Mathematica to generate the graph using the included Mathematica code. Then I used Slic3r to scale the Mathematica output to be \(80\times80\times80\) \(\text{mm}^3\) (as well as let it correct some errors in the stl file). Finally, I used Fusion 360 to design the stand.</p>

<h2 id="post-print-finishing">Post-print finishing:</h2>
<p>If desired, use a few drops of super glue to attach the surface to the stand.</p>

<h2 id="files">Files</h2>
<ul>
  <li>Continous fractional derivative of the exponential function: <a href="assets/3d-models/continuous_quadratic/Graph_Quadratic.stl">Graph_Quadratic.stl</a></li>
  <li>Stand: <a href="assets/3d-models/continuous_quadratic/Graph_Quadratic_Stand.stl">Graph_Quadratic_Stand.stl</a></li>
  <li>Mathematica Notebook: <a href="assets/3d-models/continuous_quadratic/Graph_Quadratic.nb">Graph_Quadratic.nb</a></li>
</ul>]]></content><author><name>Kevin Ahrendt</name></author><category term="3d-printing" /><category term="3d printing" /><category term="mathematics" /><summary type="html"><![CDATA[Description: This is a three dimensional graph of \(x^2\), with one axis representing the Riemann-Liouville fractional derivative order ranging from 0 to 2. The \(x\)-axis ranges from 1 to 7. The zeroth order derivative, given by \(x^2\), the first derivative, given by \(2x\), and the second derivative, given by \(2\) are highlighted with a ridge. The Riemann-Liouville fractional derivative is continuous with the respect to the order of the derivative, so the transition between the zeroth, first, and second derivative to the fractional derivatives in between results in a smooth graph.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/print-continuous-quadratic.jpg" /><media:content medium="image" url="/print-continuous-quadratic.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Discrete Fractional Difference of Quadratic Function</title><link href="/discrete_quadratic_print" rel="alternate" type="text/html" title="Discrete Fractional Difference of Quadratic Function" /><published>2019-08-05T00:00:00-04:00</published><updated>2019-08-05T00:00:00-04:00</updated><id>/discrete_quadratic_print</id><content type="html" xml:base="/discrete_quadratic_print"><![CDATA[<h2 id="description">Description:</h2>
<p>This is a three dimensional graph of the discrete function \((x+1)(x)\) defined on the natural numbers. This is an analogue to the quadratic function in the nabla discrete calculus; in particular, this function is known as the rising function. One axis represents the continuous order of the Riemann-Liouville fractional difference ranging from 0 to 2. The \(x\)-axis ranges in discrete steps from 1 to 7. The zeroth order difference, given by \((x+1)(x)\), the first difference, given by \(2x+1\), and the second difference, given by \(2\) are highlighted with a ridge. The Riemann-Liouville fractional difference is continuous with the respect to the order of the difference, so the transition between the zeroth, first, and second difference to the fractional differences in between results in a smooth graph in each discrete x-value.</p>

<h2 id="design-process">Design process:</h2>
<p>I used Mathematica to generate the graph using the included Mathematica code. Then I used Slic3r to scale the Mathematica output to be \(80\times80\times80\) \(\text{mm}^3\) (as well as let it correct some errors in the stl file). Finally, I used Fusion 360 to design the stand.</p>

<h2 id="post-print-finishing">Post-print finishing:</h2>
<p>If desired, use a few drops of super glue to attach the surface to the stand.</p>

<h2 id="files">Files</h2>
<ul>
  <li>Continous fractional derivative of the exponential function: <a href="assets/3d-models/discrete_quadratic/Graph_Discrete_Quadratic.stl">Graph_Discrete_Quadratic.stl</a></li>
  <li>Stand: <a href="assets/3d-models/discrete_quadratic/Graph_Discrete_Quadratic_Stand.stl">Graph_Discrete_Quadratic_Stand.stl</a></li>
  <li>Mathematica Notebook: <a href="assets/3d-models/discrete_quadratic/Graph_Discrete_Quadratic.nb">Graph_Discrete_Quadratic.nb</a></li>
</ul>]]></content><author><name>Kevin Ahrendt</name></author><category term="3d-printing" /><category term="3d printing" /><category term="mathematics" /><summary type="html"><![CDATA[Description: This is a three dimensional graph of the discrete function \((x+1)(x)\) defined on the natural numbers. This is an analogue to the quadratic function in the nabla discrete calculus; in particular, this function is known as the rising function. One axis represents the continuous order of the Riemann-Liouville fractional difference ranging from 0 to 2. The \(x\)-axis ranges in discrete steps from 1 to 7. The zeroth order difference, given by \((x+1)(x)\), the first difference, given by \(2x+1\), and the second difference, given by \(2\) are highlighted with a ridge. The Riemann-Liouville fractional difference is continuous with the respect to the order of the difference, so the transition between the zeroth, first, and second difference to the fractional differences in between results in a smooth graph in each discrete x-value.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/print-discrete-quadratic.jpg" /><media:content medium="image" url="/print-discrete-quadratic.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Towers of Hanoi</title><link href="/towers_of_hanoi_print" rel="alternate" type="text/html" title="Towers of Hanoi" /><published>2019-08-03T00:00:00-04:00</published><updated>2019-08-03T00:00:00-04:00</updated><id>/towers_of_hanoi_print</id><content type="html" xml:base="/towers_of_hanoi_print"><![CDATA[<h2 id="description">Description:</h2>
<p>This model represents A simple Towers of Hanoi example with four rings. <a href="https://en.wikipedia.org/wiki/Tower_of_Hanoi">Wikipedia</a> has a lot of great information on the problem.</p>

<p>This is a great example of difference equations/recursion equations in the real world! The recursion relation is given by
\(y(n+1) = 2y(n) + 1\).
We use an initial condition of \(y(1)=1\); i.e. if you have only one ring, it takes one step to move the stack to another peg. Then, our solution is given by
\(y(n) = 2^n-1\).
This means, if we use all 4 rings in this file, it takes \(2^4-1 = 15\) steps at a minimum to move the stack from one tower to the other!</p>

<h2 id="design-process">Design process:</h2>
<p>I designed this using Fusion 360.</p>

<h2 id="files">Files</h2>
<ul>
  <li>Base: <a href="assets/3d-models/towers_of_hanoi/Base.stl">Base.stl</a></li>
  <li>Four rings: <a href="assets/3d-models/towers_of_hanoi/Rings.stl">Rings.stl</a></li>
  <li>Fusion 360 Model: <a href="assets/3d-models/towers_of_hanoi/Towers_of_Hanoi.f3d">Towers_of_Hanoi.f3d</a></li>
</ul>]]></content><author><name>Kevin Ahrendt</name></author><category term="3d-printing" /><category term="3D printing" /><category term="mathematics" /><summary type="html"><![CDATA[Description: This model represents A simple Towers of Hanoi example with four rings. Wikipedia has a lot of great information on the problem.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/print-towers-of-hanoi.jpg" /><media:content medium="image" url="/print-towers-of-hanoi.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Continuous Fractional Derivative of Exponential Function</title><link href="/continuous_exponential_print" rel="alternate" type="text/html" title="Continuous Fractional Derivative of Exponential Function" /><published>2017-12-08T00:00:00-05:00</published><updated>2017-12-08T00:00:00-05:00</updated><id>/continuous_exponential_print</id><content type="html" xml:base="/continuous_exponential_print"><![CDATA[<h2 id="description">Description:</h2>
<p>This model is a three dimensional graph \(e^x\), with one axis representing the Riemann-Liouville fractional derivative order ranging from 0 to 1. The x-axis ranges from 0.05 to 1; the fractional derivative of \(e^x\) approaches infinity as x approaches 0, hence the axis starts at 0.05 avoid the asymptote. The Riemann-Liouville fractional derivative is continuous with the respect to the order of the derivative, so this graph is nice and smooth.</p>

<h2 id="design-process">Design process:</h2>
<p>I used Mathematica to generate the graph using the included Mathematica code. Then I used Slic3r to scale the Mathematica output to be \(80\times80\times80\) \(\text{mm}^3\) (as well as let it correct some errors in the stl file). Finally, I used Fusion 360 to design the stand.</p>

<h2 id="post-print-finishing">Post-print finishing:</h2>
<p>If desired, use a few drops of super glue to attach the surface to the stand.</p>

<h2 id="files">Files</h2>
<ul>
  <li>Continous fractional derivative of the exponential function: <a href="assets/3d-models/continuous_exponential/Graph_Exponential.stl">Graph_Exponential.stl</a></li>
  <li>Stand: <a href="assets/3d-models/continuous_exponential/Graph_Exponential_Stand.stl">Graph_Exponential_Stand.stl</a></li>
  <li>Mathematica Notebook: <a href="assets/3d-models/continuous_exponential/Graph_Exponential.nb">Graph_Exponential.nb</a></li>
</ul>]]></content><author><name>Kevin Ahrendt</name></author><category term="3d-printing" /><category term="3d printing" /><category term="mathematics" /><summary type="html"><![CDATA[Description: This model is a three dimensional graph \(e^x\), with one axis representing the Riemann-Liouville fractional derivative order ranging from 0 to 1. The x-axis ranges from 0.05 to 1; the fractional derivative of \(e^x\) approaches infinity as x approaches 0, hence the axis starts at 0.05 avoid the asymptote. The Riemann-Liouville fractional derivative is continuous with the respect to the order of the derivative, so this graph is nice and smooth.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/print-continous-exponential.jpg" /><media:content medium="image" url="/print-continous-exponential.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>